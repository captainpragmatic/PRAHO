#!/usr/bin/env python3
"""
Patch all pre-commit-generated git hooks for cross-platform venv resolution.

Replaces the static INSTALL_PYTHON line written by `pre-commit install` in
every hook file generated by pre-commit (pre-commit, commit-msg, pre-push,
post-checkout, etc.) with a dynamic block that resolves the correct venv
based on the current OS at runtime:
  - macOS  → .venv-darwin/bin/python
  - Linux  → .venv-linux/bin/python

Also exports UV_PROJECT_ENVIRONMENT (absolute path) so that `uv run` calls
inside hooks use the same venv, regardless of the hook's working directory.

Safe to run multiple times (idempotent — checks for PATCHED_MARKER).
"""
from __future__ import annotations

import pathlib
import re
import sys

HOOKS_DIR = pathlib.Path(".git/hooks")
PRECOMMIT_FILE_MARKER = "File generated by pre-commit: https://pre-commit.com"

# Unique sentinel that won't appear in any pre-commit-generated hook naturally.
# Increment the version if the DYNAMIC_BLOCK format ever changes.
PATCHED_MARKER = "# PRAHO_HOOK_PATCH_V1"

DYNAMIC_BLOCK = """\
# PRAHO_HOOK_PATCH_V1 — cross-platform venv resolution (patch_precommit_hook.py)
# Resolves .venv-darwin (macOS) or .venv-linux (Linux) from the repo root.
case "$(uname -s)" in
  Darwin) _PRAHO_UNAME=darwin ;;
  Linux)  _PRAHO_UNAME=linux  ;;
  *) echo "Unsupported OS: $(uname -s). Run: make install" >&2; exit 1 ;;
esac
_PRAHO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null \
  || { cd "$(dirname "$0")/../.." && pwd; })
export UV_PROJECT_ENVIRONMENT="${_PRAHO_ROOT}/.venv-${_PRAHO_UNAME}"
INSTALL_PYTHON="${UV_PROJECT_ENVIRONMENT}/bin/python"\
"""


def patch_hook(hook_path: pathlib.Path) -> bool:
    """Patch a single hook file. Returns True if patched, False if skipped."""
    text = hook_path.read_text()

    # Only patch hooks generated by pre-commit.
    if PRECOMMIT_FILE_MARKER not in text:
        return False

    # Idempotent: skip if this exact patch version is already present.
    if PATCHED_MARKER in text:
        print(f"ℹ️   {hook_path.name}: already patched (V1) — skipping.")
        return False

    patched, count = re.subn(
        r"^INSTALL_PYTHON\s*=.*$",
        DYNAMIC_BLOCK,
        text,
        count=1,  # Replace only the first (and expected only) occurrence.
        flags=re.MULTILINE,
    )

    if count == 0:
        print(
            f"⚠️   {hook_path.name}: INSTALL_PYTHON line not found — " "pre-commit format may have changed. Skipping.",
            file=sys.stderr,
        )
        return False

    hook_path.write_text(patched)
    print(f"✅  {hook_path.name}: patched for dynamic OS resolution (darwin/linux).")
    return True


def main() -> int:
    if not HOOKS_DIR.exists():
        print("❌  .git/hooks/ not found — run this script from the repo root.", file=sys.stderr)
        return 1

    hooks = sorted(p for p in HOOKS_DIR.iterdir() if p.is_file() and not p.name.endswith(".sample"))

    if not hooks:
        print("⚠️   No hooks found in .git/hooks/.", file=sys.stderr)
        return 0

    patched_count = sum(patch_hook(h) for h in hooks)

    if patched_count == 0:
        print("ℹ️   No hooks needed patching (all already patched or not pre-commit hooks).")
    else:
        print(f"\n✅  Patched {patched_count} hook(s). " "`git commit` now works on both macOS and Linux.")

    return 0


if __name__ == "__main__":
    sys.exit(main())
